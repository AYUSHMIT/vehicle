-- Grammar of Vehicle Core

comment "(*" "*)";

-- * Tokens

position token BuiltinToken
  ( {"Type"} | {"Kind"} | {"Constraint"}
  | {"all"} | {"any"}
  | {"=>"} | {"and"} | {"or"} | {"not"}
  | {"=="} | {"!="} | {"<="} | {"<"} | {">="} | {">"}
  | {"*"} | {"/"} | {"+"} | {"-"} | {"~"}
  | {"Nat"} | {"Int"} | {"Real"}
  | {"Prop"} | {"Bool"}
  | {"Tensor"} | {"List"} | {"::"} | {"!"}
  | {"Eq"} | {"Ord"} | {"Container"} | {"Number"}
  );
position token NameToken (lower (letter | digit | '_')*) ;
position token BoolToken ({"True"} | {"False"}) ;
position token MetaToken ("?" digit+);

-- * Binders

ExplicitNameAndType. Binder ::= "(" NameToken Expr1 ")";
ImplicitNameAndType. Binder ::= "{" NameToken Expr1 "}";
ExplicitName.        Binder ::= NameToken;
ImplicitName.        Binder ::= "{" NameToken "}";
ExplicitType.        Binder ::= Expr1;
EmplicitType.        Binder ::= "{" Expr1 "}";

-- * Function arguments

ImplicitArg. Arg ::= Expr1;
ExplicitArg. Arg ::= "{" Expr1 "}";

-- * Literals

LitNat.  Lit ::= Integer; -- NOTE: `Integer` parses natural numbers (not integers)
LitReal. Lit ::= Double;
LitBool. Lit ::= BoolToken;

-- * Core structure.

Kind.          Expr  ::= "kind";
App.           Expr  ::= Expr Arg;
Pi.            Expr  ::= "pi" Binder Expr1;
Lam.           Expr  ::= "lambda" Binder Expr1;
Let.           Expr  ::= "let" Binder Expr1 Expr1;
Seq.           Expr1 ::= "[" [Expr1] "]";
Ann.           Expr  ::= Expr ":type" Expr;
Builtin.       Expr1 ::= BuiltinToken;
Var.           Expr1 ::= NameToken;
Literal.       Expr1 ::= Lit;
internal Meta. Expr1 ::= MetaToken;

coercions Expr 1;
separator Expr1 "";

-- * Declarations

DeclNetw. Decl ::= "(" "declare-network" NameToken Expr1 ")";
DeclData. Decl ::= "(" "declare-dataset" NameToken Expr1 ")";
DefFun.   Decl ::= "(" "define-fun"      NameToken Expr1 Expr1 ")";

separator Decl "";

-- * Program

Main. Prog ::= "(" [Decl] ")";

