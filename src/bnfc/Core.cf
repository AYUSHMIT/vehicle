-- Grammar of Vehicle Core

comment "(*" "*)";

-- * Tokens

position token Builtin
  ( {"Type"} | {"Kind"} | {"Constraint"}
  | {"all"} | {"any"}
  | {"=>"} | {"and"} | {"or"} | {"not"}
  | {"=="} | {"!="} | {"<="} | {"<"} | {">="} | {">"}
  | {"*"} | {"/"} | {"+"} | {"-"} | {"~"}
  | {"Nat"} | {"Int"} | {"Real"}
  | {"Prop"} | {"Bool"}
  | {"Tensor"} | {"List"} | {"::"} | {"!"}
  | {"Eq"} | {"Ord"} | {"Container"} | {"Number"}
  );

position token Name (lower (letter | digit | '_')*) ;
position token Meta ('?' digit+) ;
position token Bool ({"True"} | {"False"}) ;

-- * Names for builtins, binders, and variables

ExplicitNameAndType. Binder ::= "(" Name Expr1 ")";
ExplicitName.        Binder ::= Name;
ImplicitNameAndType. Binder ::= "{" Name Expr1 "}";
ImplicitName.        Binder ::= "{" Name "}";

-- * Literals

LitNat.  Lit ::= Integer; -- NOTE: `Integer` parses natural numbers (not integers)
LitReal. Lit ::= Double;
LitBool. Lit ::= Bool;

-- Core structure.
Kind.        Expr  ::= "kind";
App.         Expr  ::= Expr Expr1;
Builtin.     Expr1 ::= Builtin;
Pi.          Expr  ::= "pi" Binder Expr1;
Lam.         Expr  ::= "lambda" Binder Expr1;
Var.         Expr1 ::= Name;
Meta.        Expr  ::= Meta;
Let.         Expr  ::= "let" Binder Expr1 Expr1;
Seq.         Expr1 ::= "[" [Expr1] "]";
Ann.         Expr  ::= Expr ":type" Expr;
Literal.     Expr1 ::= Lit;

coercions Expr 1;
separator Expr1 "";

-- * Declarations

DeclNetw. Decl ::= "(" "declare-network" Binder Expr1 ")";
DeclData. Decl ::= "(" "declare-dataset" Binder Expr1 ")";
DefFun.   Decl ::= "(" "define-fun"      Binder Expr1 Expr1 ")";

separator Decl "";

-- * Program

Main. Prog ::= "(" [Decl] ")";

