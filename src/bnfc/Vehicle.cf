-- Grammar of Vehicle

comment "--";
comment "{-" "-}";

-- * Tokens

position token UIdent (upper (letter | digit | '_')*) ;
position token LIdent (lower (letter | digit | '_')*) ;

separator UIdent "";
separator LIdent "";


-- * Kinds

KApp.  Kind  ::= Kind Kind1;
KStar. Kind1 ::= "*";
KNat.  Kind1 ::= "Nat";
KList. Kind1 ::= "List";

coercions Kind 1;


-- * Types

TFun.    Type1 ::= Type "->" Type2;
TForall. Type1 ::= "forall" [LIdent] "." Type2;
TAdd.    Type2 ::= Type2 "+" Type3;
TApp.    Type3 ::= Type3 Type4;
TVar.    Type4 ::= LIdent;
TNil.    Type4 ::= "Nil";
TCons.   Type4 ::= "Cons";
TTensor. Type4 ::= "Tensor";
TBool.   Type4 ::= "Bool";
TReal.   Type4 ::= "Real";
TNat.    Type4 ::= "Nat";
TListOf. Type4 ::= "[" [Type] "]";

coercions Type 4;

separator Type ",";


-- * Expressions

-- NOTE:
--
--   The syntax for expressions used by the parser is more general than that
--   permitted by our bidirectional typing, which allows us to emit an more
--   specific error message when we're missing a type annotation, rather than
--   emitting a parse error.
--

layout "let";
layout stop "in";

EAnn.    Expr  ::= Expr1 "::" Type;
ELet.    Expr1 ::= "let" "{" [Decl] "}" "in" Expr1;
EIf.     Expr1 ::= "if" Expr2 "then" Expr2 "else" Expr2;
ELam.    Expr2 ::= "\\" [LIdent] "->" Expr2;
EEq.     Expr3 ::= Expr3 "==" Expr3;
ELe.     Expr3 ::= Expr3 "<=" Expr3;
ELt.     Expr3 ::= Expr3 "<" Expr3;
EGe.     Expr3 ::= Expr3 ">=" Expr3;
EGt.     Expr3 ::= Expr3 ">" Expr3;
EMul.    Expr4 ::= Expr4 "*" Expr5;
EDiv.    Expr4 ::= Expr4 "/" Expr5;
EAdd.    Expr5 ::= Expr5 "+" Expr6;
ESub.    Expr5 ::= Expr5 "-" Expr6;
EApp.    Expr6 ::= Expr6 Expr7;
EVar.    Expr7 ::= LIdent;
ETensor. Expr7 ::= Tensor1;
ETrue.   Expr7 ::= "True";
EFalse.  Expr7 ::= "False";

-- NOTE:
--
--   Type application and abstraction aren't part of the surface syntax, so
--   they're marked as 'internal'.
--

internal ETyApp. Expr ::= Expr Type;
internal ETyLam. Expr ::= "\\" [LIdent] "->" Expr;

coercions Expr 7;


-- * Tensors

ADouble. Tensor  ::= Double;
AList.   Tensor  ::= "[" [Tensor1] "]";
AExpr.   Tensor1 ::= Expr;

coercions Tensor 1;

separator Tensor1 ",";


-- * Declarations

TDecl. Decl ::= LIdent ":" Type;
EDecl. Decl ::= LIdent [LIdent] "=" Expr;

separator nonempty Decl ";";
