-- Grammar of Vehicle

comment "--";
comment "{-" "-}";

-- * Tokens

position token UIdent (upper (letter | digit | '_')*) ;
position token LIdent (lower (letter | digit | '_')*) ;
position token Infix ([".:-^*+=<>&%$!#%|/\\"]+) ;

separator UIdent "";
separator LIdent "";


-- * Kinds

KApp.  Kind  ::= Kind Kind1;
KStar. Kind1 ::= "*";
KNat.  Kind1 ::= "Nat";
KList. Kind1 ::= "List";

coercions Kind 1;


-- * Types

TFun.    Type ::= Type1 "->" Type;
TForall. Type ::= "forall" [LIdent] "." Type;
TAdd.    Type1 ::= Type1 "+" Type2;
TApp.    Type2 ::= Type2 Type3;
TVar.    Type3 ::= LIdent;
TLitNat. Type3 ::= Integer; -- confusingly, this means Natural
TNil.    Type3 ::= "Nil";
TCons.   Type3 ::= "Cons";
TTensor. Type3 ::= "Tensor";
TBool.   Type3 ::= "Bool";
TReal.   Type3 ::= "Real";
TNat.    Type3 ::= "Nat";
TListOf. Type3 ::= "[" [Type] "]";

coercions Type 4;

separator Type ",";


-- * Expressions

-- NOTE:
--
--   The syntax for expressions used by the parser is more general than that
--   permitted by our bidirectional typing, which allows us to emit an more
--   specific error message when we're missing a type annotation, rather than
--   emitting a parse error.
--

layout "let";
layout stop "in";

EAnn.      Expr   ::= Expr1 ":" Type;
EForall.   Expr   ::= "forall" LIdent ":" Bound "." Expr;
EExists.   Expr   ::= "exists" LIdent ":" Bound "." Expr;
ELet.      Expr1	::= "let" "{" [Decl] "}" "in" Expr1;
EIf.       Expr1	::= "if" Expr2 "then" Expr2 "else" Expr2;
ELam.      Expr2	::= "\\" [LIdent] "->" Expr2;
EImpl.     Expr3	::= Expr4 "=>" Expr3;
EAnd.      Expr4	::= Expr5 "&&" Expr4;
EOr.       Expr5	::= Expr6 "||" Expr5;
EEq.       Expr6	::= Expr7 "==" Expr7;
ENeq.      Expr6	::= Expr7 "!=" Expr7;
ELe.       Expr6	::= Expr7 "<=" Expr7;
ELt.       Expr6	::= Expr7 "<"  Expr7;
EGe.       Expr6	::= Expr7 ">=" Expr7;
EGt.       Expr6	::= Expr7 ">"  Expr7;
EMul.      Expr7	::= Expr7 "*"  Expr8;
EDiv.      Expr7	::= Expr7 "/"  Expr8;
EAdd.      Expr8	::= Expr8 "+"  Expr9;
ESub.      Expr8	::= Expr8 "-"  Expr9;
ENeg.      Expr9  ::= "-" Expr9;
ENot.      Expr9	::= "~" Expr9;
EAt.       Expr10 ::= Expr10 "!" Expr11;
EApp.      Expr11 ::= Expr11 Expr12;
EVar.      Expr12 ::= LIdent;
ELitNat.   Expr12 ::= Integer;
ELitReal.  Expr12 ::= Double;
ETensor.   Expr12 ::= "[" [Expr] "]";
ETrue.     Expr12 ::= "True";
EFalse.    Expr12 ::= "False";

-- NOTE:
--
--   Type application and abstraction aren't part of the surface syntax, so
--   they're marked as 'internal'.
--

internal ETyApp. Expr ::= Expr Type;
internal ETyLam. Expr ::= "\\" [LIdent] "->" Expr;

coercions Expr 12;

separator Expr ",";

-- * Bounds for quantifiers

BType. Bound ::= Type;
BExpr. Bound ::= Expr;


-- * Declarations

DeclNetw. Decl ::= "network" LIdent ":" Type;
DeclType. Decl ::= LIdent ":" Type;
DeclExpr. Decl ::= LIdent [LIdent] "=" Expr;

separator Decl ";";

-- * Program

layout toplevel;

Main. Prog ::= [Decl]
