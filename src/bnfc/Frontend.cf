-- Grammar of Vehicle

comment "--";
comment "{-" "-}";

-- * Tokens

-- NOTE: Token rules are tried IN ORDER, so the order matters!

position token TokArrow    {"->"};
position token TokForall   {"forall"};
position token TokExists   {"exists"};
position token TokDot      {"."};
position token TokElemOf   {":"};
position token TokLambda   {"\\"};

position token TokImpl     {"=>"};
position token TokAnd      {"&&"};
position token TokOr       {"||"};
position token TokEq       {"=="};
position token TokNeq      {"!="};
position token TokLe       {"<="};
position token TokLt       {"<"};
position token TokGe       {">="};
position token TokGt       {">"};
position token TokMul      {"*"};
position token TokDiv      {"/"};
position token TokAdd      {"+"};
position token TokSub      {"-"};
position token TokNeg      {"~"};
position token TokAt       {"!"};

position token TokType     {"Type"};
position token TokReal     {"Real"};
position token TokNat      {"Nat"};
position token TokBool     {"Bool"};
position token TokTrue     {"True"};
position token TokFalse    {"False"};
position token TokList     {"List"};
position token TokNil      {"Nil"};
position token TokCons     {"Cons"};
position token TokTensor   {"Tensor"};
position token TokSeqOpen  {"["};
position token TokSeqClose {"]"};

position token Nat (digit+);
position token Real (digit+ '.' digit+ ('e' '-'? digit+)?);
position token Name (lower (letter | digit | '_')*) ;

separator Name "";


-- * Kinds

KApp.  Kind  ::= Kind Kind1;
KType. Kind1 ::= TokType;
KNat.  Kind1 ::= TokNat;
KList. Kind1 ::= TokList;

coercions Kind 1;


-- * Types

TFun.    Type  ::= Type1 TokArrow Type;
TForall. Type  ::= TokForall [Name] TokDot Type;
TAdd.    Type1 ::= Type1 TokAdd Type2;
TApp.    Type2 ::= Type2 Type3;
TVar.    Type3 ::= Name;
TLitNat. Type3 ::= Nat;
TNil.    Type3 ::= TokNil;
TCons.   Type3 ::= TokCons;
TTensor. Type3 ::= TokTensor;
TBool.   Type3 ::= TokBool;
TReal.   Type3 ::= TokReal;
TNat.    Type3 ::= TokNat;
TListOf. Type3 ::= TokSeqOpen [Type] TokSeqClose;

coercions Type 4;

separator Type ",";


-- * Expressions

-- NOTE:
--
--   The syntax for expressions used by the parser is more general than that
--   permitted by our bidirectional typing, which allows us to emit an more
--   specific error message when we're missing a type annotation, rather than
--   emitting a parse error.
--

layout "let";
layout stop "in";

EAnn.      Expr   ::= Expr1 TokElemOf Type;
EForall.   Expr   ::= TokForall Name TokElemOf Bound TokDot Expr;
EExists.   Expr   ::= TokExists Name TokElemOf Bound TokDot Expr;
ELet.      Expr1  ::= "let" "{" [Decl] "}" "in" Expr1;
EIf.       Expr1  ::= "if" Expr2 "then" Expr2 "else" Expr2;
ELam.      Expr2  ::= TokLambda [Name] TokArrow Expr2;
EImpl.     Expr3  ::= Expr4 TokImpl Expr3;
EAnd.      Expr4  ::= Expr5 TokAnd  Expr4;
EOr.       Expr5  ::= Expr6 TokOr   Expr5;
EEq.       Expr6  ::= Expr7 TokEq   Expr7;
ENeq.      Expr6  ::= Expr7 TokNeq  Expr7;
ELe.       Expr6  ::= Expr7 TokLe   Expr7;
ELt.       Expr6  ::= Expr7 TokLt   Expr7;
EGe.       Expr6  ::= Expr7 TokGe   Expr7;
EGt.       Expr6  ::= Expr7 TokGt   Expr7;
EMul.      Expr7  ::= Expr7 TokMul  Expr8;
EDiv.      Expr7  ::= Expr7 TokDiv  Expr8;
EAdd.      Expr8  ::= Expr8 TokAdd  Expr9;
ESub.      Expr8  ::= Expr8 TokSub  Expr9;
ENeg.      Expr9  ::= TokNeg Expr9;
EAt.       Expr10 ::= Expr10 TokAt Expr11;
EApp.      Expr11 ::= Expr11 Expr12;
EVar.      Expr12 ::= Name;
ELitNat.   Expr12 ::= Nat;
ELitReal.  Expr12 ::= Real;
ETensor.   Expr12 ::= TokSeqOpen [Expr] TokSeqClose;
ETrue.     Expr12 ::= TokTrue;
EFalse.    Expr12 ::= TokFalse;

-- NOTE:
--
--   Type application and abstraction aren't part of the surface syntax, so
--   they're marked as 'internal'.
--

internal ETyApp. Expr ::= Expr Type;
internal ETyLam. Expr ::= TokLambda [Name] TokArrow Expr;

coercions Expr 12;

separator Expr ",";

-- * Bounds for quantifiers

BType. Bound ::= Type;
BExpr. Bound ::= Expr;


-- * Declarations

DeclNetw. Decl ::= "network" Name TokElemOf Type;
DeclType. Decl ::= Name TokElemOf Type;
DeclExpr. Decl ::= Name [Name] "=" Expr;

separator Decl ";";

-- * Program

layout toplevel;

Main. Prog ::= [Decl]
