-- Grammar of the Vehicle External language

comment "--";
comment "{-" "-}";

-- * Tokens

-- NOTE: Token rules are tried IN ORDER, so the order matters!

position token TokArrow     {"->"};
position token TokForallT   {"forallT"};
position token TokIf        {"if"};
position token TokThen      {"then"};
position token TokElse      {"else"};
position token TokDot       {"."};
position token TokElemOf    {":"};
position token TokLambda    {"\\"};

position token TokTensor    {"Tensor"};
position token TokList      {"List"};
position token TokReal      {"Real"};
position token TokRat       {"Rat"};
position token TokInt       {"Int"};
position token TokNat       {"Nat"};
position token TokBool      {"Bool"};
position token TokIndex     {"Index"};

position token TokForall    {"forall"};
position token TokExists    {"exists"};
position token TokImpl      {"=>"};
position token TokAnd       {"and"};
position token TokOr        {"or"};
position token TokNot       {"not"};
position token TokEq        {"=="};
position token TokNeq       {"!="};
position token TokLe        {"<="};
position token TokLt        {"<"};
position token TokGe        {">="};
position token TokGt        {">"};
position token TokMul       {"*"};
position token TokDiv       {"/"};
position token TokAdd       {"+"};
position token TokSub       {"-"};

position token TokSeqOpen   {"["};
position token TokSeqClose  {"]"};
position token TokCons      {"::"};
position token TokAt        {"!"};
position token TokMap       {"map"};
position token TokFold      {"fold"};

position token TokTrue      {"True"};
position token TokFalse     {"False"};

position token TokTCEq        {"HasEq"};
position token TokTCOrd       {"HasOrd"};
position token TokTCNatOps    {"HasNatOperations"};
position token TokTCIntOps    {"HasIntOperations"};
position token TokTCRatOps    {"HasRatOperations"};
position token TokTCConOps    {"HasContainerOperations"};
position token TokTCNatLits   {"HasNatLiteralsUpTo"};
position token TokTCIntLits   {"HasIntLiterals"};
position token TokTCRatLits   {"HasRatLiterals"};
position token TokTCConLits   {"HasContainerLiteralsOfSize"};

position token TokLet {"let"};

position token Name        (letter (letter | digit | '_')*) ;
position token HoleToken   ({"?"} (letter | digit | '_')*);
position token TypeToken   ({"Type"} digit+);

position token Natural  (digit+);
position token Rational (digit+ '.' digit+);

separator Name "";


-- * Binders

ExplicitBinder.    Binder ::= Name;
ExplicitBinderAnn. Binder ::= "(" Name TokElemOf Expr1 ")";
ImplicitBinder.    Binder ::= "{" Name "}";
ImplicitBinderAnn. Binder ::= "{" Name TokElemOf Expr1 "}";
InstanceBinder.    Binder ::= "{{" Name "}}";
InstanceBinderAnn. Binder ::= "{{" Name TokElemOf Expr1 "}}";

separator Binder "";

-- * Arguments

ExplicitArg. Arg ::= Expr15;
ImplicitArg. Arg ::= "{" Expr1 "}";
InstanceArg. Arg ::= "{{" Expr1 "}}";

-- * Individual let declarations

LDecl. LetDecl ::= Binder "=" Expr;

separator LetDecl ",";

-- * Literals

LitNat.   Lit ::= Natural;
LitRat.   Lit ::= Rational;
LitTrue.  Lit ::= TokTrue;
LitFalse. Lit ::= TokFalse;


-- * Expressions

-- NOTE:
--
--   The syntax for expressions used by the parser is more general than that
--   permitted by our bidirectional typing, which allows us to emit an more
--   specific error message when we're missing a type annotation, rather than
--   emitting a parse error.
--
--   See https://github.com/BNFC/bnfc/issues/372 for why tokens
--   aren't used for `let` and `in`.

-- Kinds.
Type.    Expr15 ::= TypeToken;

-- Core structure.
Ann.     Expr   ::= Expr2 TokElemOf Expr1;
ForallT. Expr1  ::= TokForallT [Binder] TokDot Expr1;
Let.     Expr2  ::= TokLet [LetDecl] "in" Expr2;
Lam.     Expr2  ::= TokLambda [Binder] TokArrow Expr2;
Fun.     Expr11 ::= Expr13 TokArrow Expr11;
App.     Expr13 ::= Expr13 Arg;
Var.     Expr15 ::= Name;
Literal. Expr15 ::= Lit;
Hole.    Expr15 ::= HoleToken;

-- Quantification
Forall.    Expr2 ::= TokForall [Binder] TokDot Expr2;
Exists.    Expr2 ::= TokExists [Binder] TokDot Expr2;
ForallIn.  Expr2 ::= TokForall [Binder] "in" Expr3 TokDot Expr2;
ExistsIn.  Expr2 ::= TokExists [Binder] "in" Expr3 TokDot Expr2;

-- Boolean expressions.
If.      Expr4  ::= TokIf Expr5 TokThen Expr5 TokElse Expr5;
Impl.    Expr5  ::= Expr6 TokImpl Expr5;
And.     Expr7  ::= Expr8 TokAnd Expr7;
Or.      Expr7  ::= Expr8 TokOr  Expr7;
Eq.      Expr8  ::= Expr9 TokEq  Expr9;
Neq.     Expr8  ::= Expr9 TokNeq Expr9;
Not.     Expr11 ::= TokNot Expr11;

-- Numeric expressions.
Le.      Expr8  ::= Expr8  TokLe  Expr9;
Lt.      Expr8  ::= Expr8  TokLt  Expr9;
Ge.      Expr8  ::= Expr8  TokGe  Expr9;
Gt.      Expr8  ::= Expr8  TokGt  Expr9;
Add.     Expr9  ::= Expr9  TokAdd Expr10;
Sub.     Expr9  ::= Expr9  TokSub Expr10;
Mul.     Expr10 ::= Expr10 TokMul Expr11;
Div.     Expr10 ::= Expr10 TokDiv Expr11;
Neg.     Expr11 ::= TokSub Expr11;

-- Lists and tensors.
LSeq.    Expr15 ::= TokSeqOpen [Expr] TokSeqClose;
Cons.    Expr4  ::= Expr5 TokCons Expr4;
At.      Expr12 ::= Expr12 TokAt Expr13;
Map.     Expr13 ::= TokMap Expr15 Expr15;
Fold.    Expr13 ::= TokFold Expr15 Expr15 Expr15;

-- Primitive types.
List.    Expr14 ::= TokList Expr15;
Tensor.  Expr14 ::= TokTensor Expr15 Expr15;
Index.   Expr14 ::= TokIndex Expr15;
Bool.    Expr15 ::= TokBool;
Real.    Expr15 ::= TokReal;
Rat.     Expr15 ::= TokRat;
Int.     Expr15 ::= TokInt;
Nat.     Expr15 ::= TokNat;

-- Type classes
TCEq.      Expr15 ::= TokTCEq        Expr15;
TCOrd.     Expr15 ::= TokTCOrd       Expr15;
TCNatOps.  Expr15 ::= TokTCNatOps    Expr15;
TCIntOps.  Expr15 ::= TokTCIntOps    Expr15;
TCRatOps.  Expr15 ::= TokTCRatOps    Expr15;
TCConOps.  Expr15 ::= TokTCConOps    Expr15 Expr15;
-- Natural literals type-class also stores the value
-- which needs to be expressed (used for finite index types).
TCNatLits. Expr15 ::= TokTCNatLits Integer Expr15;
TCIntLits. Expr15 ::= TokTCIntLits   Expr15;
TCRatLits. Expr15 ::= TokTCRatLits   Expr15;
-- Container literals type-class also stores the size
-- of the container which is needed for tensors.
TCConLits. Expr15 ::= TokTCConLits Integer Expr15 Expr15;

coercions Expr 15;
separator Expr ",";

-- * Declarations

DeclNetw.      Decl ::= "network"            Name TokElemOf Expr;
DeclData.      Decl ::= "dataset"            Name TokElemOf Expr;
DeclParam.     Decl ::= "parameter"          Name TokElemOf Expr;
DeclImplParam. Decl ::= "implicit parameter" Name TokElemOf Expr;
DefType.       Decl ::= "type" Name [Binder] "=" Expr;
DefFunType.    Decl ::= Name TokElemOf Expr;
DefFunExpr.    Decl ::= Name [Binder] "=" Expr;

separator Decl ";";


-- * Program

layout toplevel;

Main. Prog ::= [Decl]
