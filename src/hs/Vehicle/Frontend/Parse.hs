{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE OverloadedStrings #-}

{-# OPTIONS_GHC -Wno-orphans #-}

{-# LANGUAGE ConstraintKinds #-}
module Vehicle.Frontend.Parse
  ( parseText
  , parseFile
  , ParseError(..)
  ) where

import Data.Text (Text, unpack)
import qualified Data.Text.IO as T
import Data.List.NonEmpty (NonEmpty(..))
import qualified Data.List.NonEmpty as NonEmpty (groupBy1, map, head)
import System.Exit (exitFailure)
import Control.Monad.Except (MonadError, throwError)


import Vehicle.Frontend.Abs as B
import Vehicle.Frontend.Layout (resolveLayout)
import Vehicle.Frontend.Lex as L (Token)
import Vehicle.Frontend.Par (pProg, myLexer)

import qualified Vehicle.Frontend.AST as V
import Vehicle.Frontend.AST.Utils (annotation)

import Vehicle.Prelude (K(..), KnownSort, Token(..), Symbol, tkSymbol, IsToken)
import Vehicle.Prelude.Provenance (Provenance (..), tkProvenance, HasProvenance(..))

--------------------------------------------------------------------------------
-- * Type synonyms

type PTree = V.Tree (K Provenance)
type PKind = V.Kind (K Provenance)
type PType = V.Type (K Provenance)
type PTArg = V.TArg (K Provenance)
type PExpr = V.Expr (K Provenance)
type PEArg = V.EArg (K Provenance)
type PDecl = V.Decl (K Provenance)
type PProg = V.Prog (K Provenance)

--------------------------------------------------------------------------------
-- Parsing


parseText :: Text -> Either ParseError PProg
parseText txt = case runParser True pProg txt of
  Left err1       -> Left $ BNFCParseError err1
  Right bnfcProg -> case conv bnfcProg of
    Left err2  -> Left err2
    Right prog -> Right prog

parseFile :: FilePath -> IO PProg
parseFile file = do
  contents <- T.readFile file
  case parseText contents of
    Left err -> do print err; exitFailure
    Right ast -> return ast


type Parser a = [L.Token] -> Either String a

runParser :: Bool -> Parser a -> Text -> Either String a
runParser topLevel p t = p (runLexer topLevel t)

runLexer :: Bool -> Text -> [L.Token]
runLexer topLevel = resolveLayout topLevel . myLexer

--------------------------------------------------------------------------------
-- Errors

data ParseError
  = MissingDefFunType Symbol Provenance
  | MissingDefFunExpr Symbol Provenance
  | DuplicateName     Symbol (NonEmpty Provenance)
  | LocalDeclNetw     Provenance
  | LocalDeclData     Provenance
  | LocalDefType      Provenance
  | EmptyList         Provenance
  | BNFCParseError    String

-- TODO change to pretty printing
instance Show ParseError where
  show = \case
    MissingDefFunType name p -> "No definition provided for function " <> unpack name  <> " (" <> show p <> ")"
    MissingDefFunExpr name p -> "No type provided for function "       <> unpack name  <> " (" <> show p <> ")"
    DuplicateName     name p -> "Duplicate definitions found for "     <> unpack name  <> " (" <> show p <> ")"
    LocalDeclNetw     p      -> "Network declarations are not allowed in let bindings" <> " (" <> show p <> ")"
    LocalDeclData     p      -> "Dataset declarations are not allowed in let bindings" <> " (" <> show p <> ")"
    LocalDefType      p      -> "Type declarations are not allowed in let bindings"    <> " (" <> show p <> ")"
    EmptyList         p      -> "Must have a non-empty list of tokens"                 <> " (" <> show p <> ")"
    BNFCParseError    text   -> text

--------------------------------------------------------------------------------
-- Conversion from BNFC AST
--
-- We convert from the simple AST generated automatically by BNFC to our
-- more complicated internal version of the AST which allows us to annotate
-- terms with sort-dependent types.
--
-- While doing this we:
--  1. extract the positions from the tokens generated by BNFC and convert them
--     into `Provenance` annotations.
--  2. combine function types and expressions into a single AST node

-- | Constraint for the monad stack used by the elaborator.
type MonadParse m = MonadError ParseError m

-- * Provenance

-- | A slightly shorter name for `tkProvenance`
tkProv :: IsToken a => a -> Provenance
tkProv = tkProvenance

instance KnownSort sort => HasProvenance (V.Tree (K Provenance) sort) where
  prov = unK . annotation

-- * Conversion

class Convert vf vc where
  conv :: MonadParse m => vf -> m vc

instance Convert B.Kind PKind where
  conv (B.KApp k1 k2)    = op2 V.KApp  mempty (conv k1) (conv k2)
  conv (B.KFun k1 tk k2) = op2 V.KFun  (tkProv tk) (conv k1) (conv k2)
  conv (B.KType tk)      = op0 V.KType (tkProv tk)
  conv (B.KDim tk)       = op0 V.KDim  (tkProv tk)
  conv (B.KList tk)      = op0 V.KList (tkProv tk)

instance Convert B.Type PType where
  conv (B.TForall tk1 ns tk2 t)   = op2 V.TForall (tkProv tk1 <> tkProv tk2) (traverseNonEmpty tk1 tk2 ns) (conv t)
  conv (B.TApp t1 t2)             = op2 V.TApp mempty (conv t1) (conv t2)
  conv (B.TVar n)                 = return $ V.TVar (K (tkProv n)) (tkSymbol n)
  conv (B.TFun t1 tk t2)          = op2 V.TFun (tkProv tk) (conv t1) (conv t2)
  conv (B.TBool tk)               = op0 V.TBool (tkProv tk)
  conv (B.TProp tk)               = op0 V.TProp (tkProv tk)
  conv (B.TReal tk)               = op0 V.TReal (tkProv tk)
  conv (B.TInt tk)                = op0 V.TInt (tkProv tk)
  conv (B.TList tk t)             = op1 V.TList (tkProv tk) (conv t)
  conv (B.TTensor tk t1 t2)       = op2 V.TTensor (tkProv tk) (conv t1) (conv t2)
  conv (B.TAdd t1 tk t2)          = op2 V.TAdd (tkProv tk) (conv t1) (conv t2)
  conv (B.TLitDim i)              = return $ V.TLitDim mempty i
  conv (B.TCons t1 tk t2)         = op2 V.TCons (tkProv tk) (conv t1) (conv t2)
  conv (B.TLitDimList tk1 ts tk2) = op1 V.TLitDimList (tkProv tk1 <> tkProv tk2) (traverseNonEmpty tk1 tk2 ts)

instance Convert Name PTArg where
  conv n = return $ V.TArg (K (tkProv n)) (tkSymbol n)

instance Convert B.Expr PExpr where
  conv (B.EAnn e tk t)              = op2 V.EAnn (tkProv tk) (conv e) (conv t)
  conv (B.ELet ds e)                = op2 V.ELet mempty (filterLetDecls ds >>= groupDecls mempty) (conv e)
  conv (B.ELam tk1 ns tk2 e)        = op2 V.ELam (tkProv tk1 <> tkProv tk2) (traverseNonEmpty tk1 tk2 ns) (conv e)
  conv (B.EApp e1 e2)               = op2 V.EApp mempty (conv e1) (conv e2)
  conv (B.EVar n)                   = return $ V.EVar (K (tkProv n)) (tkSymbol n)
  conv (B.ETyApp e t)               = op2 V.ETyApp mempty (conv e) (conv t)
  conv (B.ETyLam tk1 ns tk2 e)      = op2 V.ETyLam (tkProv tk1 <> tkProv tk2) (traverseNonEmpty tk1 tk2 ns) (conv e)
  conv (B.EIf tk1 e1 tk2 e2 tk3 e3) = op3 V.EIf    (tkProv tk1 <> tkProv tk2 <> tkProv tk3) (conv e1) (conv e2) (conv e3)
  conv (B.EImpl e1 tk e2)           = op2 V.EImpl  (tkProv tk) (conv e1) (conv e2)
  conv (B.EAnd e1 tk e2)            = op2 V.EAnd   (tkProv tk) (conv e1) (conv e2)
  conv (B.EOr e1 tk e2)             = op2 V.EOr    (tkProv tk) (conv e1) (conv e2)
  conv (B.ENot tk e)                = op1 V.ENot   (tkProv tk) (conv e)
  conv (B.ETrue tk)                 = op0 V.ETrue  (tkProv tk)
  conv (B.EFalse tk)                = op0 V.EFalse (tkProv tk)
  conv (B.EEq e1 tk e2)             = op2 V.EEq    (tkProv tk) (conv e1) (conv e2)
  conv (B.ENeq e1 tk e2)            = op2 V.ENeq   (tkProv tk) (conv e1) (conv e2)
  conv (B.ELe e1 tk e2)             = op2 V.ELe    (tkProv tk) (conv e1) (conv e2)
  conv (B.ELt e1 tk e2)             = op2 V.ELt    (tkProv tk) (conv e1) (conv e2)
  conv (B.EGe e1 tk e2)             = op2 V.EGe    (tkProv tk) (conv e1) (conv e2)
  conv (B.EGt e1 tk e2)             = op2 V.EGt    (tkProv tk) (conv e1) (conv e2)
  conv (B.EMul e1 tk e2)            = op2 V.EMul   (tkProv tk) (conv e1) (conv e2)
  conv (B.EDiv e1 tk e2)            = op2 V.EDiv   (tkProv tk) (conv e1) (conv e2)
  conv (B.EAdd e1 tk e2)            = op2 V.EAdd   (tkProv tk) (conv e1) (conv e2)
  conv (B.ESub e1 tk e2)            = op2 V.ESub   (tkProv tk) (conv e1) (conv e2)
  conv (B.ENeg tk e)                = op1 V.ENeg   (tkProv tk) (conv e)
  conv (B.ELitInt i)                = return $ V.ELitInt mempty i
  conv (B.ELitReal d)               = return $ V.ELitReal mempty d
  conv (B.ECons e1 tk e2)           = op2 V.ECons  (tkProv tk) (conv e1) (conv e2)
  conv (B.EAt e1 tk e2)             = op2 V.EAt    (tkProv tk) (conv e1) (conv e2)
  conv (B.EAll tk)                  = op0 V.EAll   (tkProv tk)
  conv (B.EAny tk)                  = op0 V.EAny   (tkProv tk)
  conv (B.ELitSeq tk1 es tk2)       = op1 V.ELitSeq (tkProv tk1 <> tkProv tk2) (traverseNonEmpty tk1 tk2 es)

instance Convert Name PEArg where
  conv n = return $ V.EArg (K (tkProv n)) (tkSymbol n)

-- |Elaborate declarations.
instance Convert (NonEmpty B.Decl) PDecl where

  -- Elaborate a network declaration.
  conv [B.DeclNetw n tk t] = op2 V.DeclNetw (tkProv tk) (conv n) (conv t)

  -- Elaborate a dataset declaration.
  conv [B.DeclData n tk t] = op2 V.DeclData (tkProv tk) (conv n) (conv t)

  -- Elaborate a type definition.
  conv [B.DefType n ns t] = op3 V.DefType mempty (conv n) (traverse conv ns) (conv t)

  -- Elaborate a function definition.
  conv [B.DefFunType n tk t, B.DefFunExpr n2 ns e] =
    op4 V.DefFun (tkProv tk <> tkProv n2) (conv n) (conv t) (traverse conv ns) (conv e)

  -- Why did you write the signature AFTER the function?
  conv [e1@B.DefFunExpr {}, e2@B.DefFunType {}] =
    conv (e2 :| [e1])

  -- Missing type or expression declaration.
  conv [B.DefFunType n _tk _t] =
    throwError $ MissingDefFunExpr (tkSymbol n) (tkProv n)

  conv [B.DefFunExpr n _ns _e] =
    throwError $ MissingDefFunType (tkSymbol n) (tkProv n)

  -- Multiple type of expression declarations with the same n.
  conv ds =
    throwError $ DuplicateName symbol provs
      where
        symbol = tkSymbol $ declName $ NonEmpty.head ds
        provs  = NonEmpty.map (tkProv . declName) ds

-- |Elaborate programs.
instance Convert B.Prog PProg where
  conv (B.Main decls) = op1 V.Main mempty (groupDecls mempty decls)

op0 :: MonadParse m
    => (K Provenance sort -> PTree sort)
    -> Provenance -> m (PTree sort)
op0 mk p = return $ mk (K p)

op1 :: (MonadParse m, HasProvenance a)
    => (K Provenance sort -> a -> PTree sort)
    -> Provenance -> m a -> m (PTree sort)
op1 mk p t = do
  ct <- t
  return $ mk (K (p <> prov ct)) ct

op2 :: (MonadParse m, HasProvenance a, HasProvenance b)
    => (K Provenance sort -> a -> b -> PTree sort)
    -> Provenance -> m a -> m b -> m (PTree sort)
op2 mk p t1 t2 = do
  ct1 <- t1
  ct2 <- t2
  return $ mk (K (p <> prov ct1 <> prov ct2)) ct1 ct2

op3 :: (MonadParse m, HasProvenance a, HasProvenance b, HasProvenance c)
    => (K Provenance sort -> a -> b -> c -> PTree sort)
    -> Provenance -> m a -> m b -> m c -> m (PTree sort)
op3 mk p t1 t2 t3 = do
  ct1 <- t1
  ct2 <- t2
  ct3 <- t3
  return $ mk (K (p <> prov ct1 <> prov ct2 <> prov ct3)) ct1 ct2 ct3

op4 :: (MonadParse m, HasProvenance a, HasProvenance b, HasProvenance c, HasProvenance d)
    => (K Provenance sort -> a -> b -> c -> d -> PTree sort)
    -> Provenance -> m a -> m b -> m c -> m d -> m (PTree sort)
op4 mk p t1 t2 t3 t4 = do
  ct1 <- t1
  ct2 <- t2
  ct3 <- t3
  ct4 <- t4
  return $ mk (K (p <> prov ct1 <> prov ct2 <> prov ct3 <> prov ct4)) ct1 ct2 ct3 ct4

-- |Filter a let binding's declarations to strip out invalid declarations.
-- TODO would probably be better to be more precise in the grammar
filterLetDecls :: MonadParse m => [ B.Decl ] -> m [ B.Decl ]
filterLetDecls = traverse declToLet
  where
    declToLet :: MonadParse m => B.Decl -> m B.Decl
    declToLet (B.DeclNetw n _n _t)  = throwError $ LocalDeclNetw (tkProv n)
    declToLet (B.DeclData n _n _t)  = throwError $ LocalDeclData (tkProv n)
    declToLet (B.DefType  n _ns _t) = throwError $ LocalDefType  (tkProv n)
    declToLet d                     = return d

-- |Takes a list of declarations, and groups type and expression
--  declarations for the same name. If any name does not have exactly one
--  type and one expression declaration, an error is returned.
groupDecls :: MonadParse m => Provenance -> [B.Decl] -> m (NonEmpty PDecl)
groupDecls p  []       = throwError $ EmptyList p
groupDecls _p (d : ds) = traverse conv (NonEmpty.groupBy1 cond (d :| ds))
  where
    cond :: B.Decl -> B.Decl -> Bool
    cond d1 d2 = isDefFun d1 && isDefFun d2 && tkSymbol (declName d1) == tkSymbol (declName d2)

-- |Check if a declaration is a network declaration.
isDefFun :: B.Decl -> Bool
isDefFun (B.DefFunType _name _args _exp) = True
isDefFun (B.DefFunExpr _ann _name _typ)       = True
isDefFun _                                    = False

-- |Get the name for any declaration.
declName :: B.Decl -> Name
declName (DeclNetw   n _ _) = n
declName (DeclData   n _ _) = n
declName (DefType    n _ _) = n
declName (DefFunType n _ _) = n
declName (DefFunExpr n _ _) = n


-- A traversal that checks that the list is non-empty. In theory this would be
-- much nicer if the parser could handle this automatically
-- (see https://github.com/BNFC/bnfc/issues/371)
traverseNonEmpty :: (MonadParse m , Convert a b, IsToken t1, IsToken t2)
                 => t1 -> t2 -> [a] -> m (NonEmpty b)
traverseNonEmpty tk1 tk2 []       = throwError $ EmptyList (tkProv tk1 <> tkProv tk2)
traverseNonEmpty _   _   (x : xs) = traverse conv (x :| xs)