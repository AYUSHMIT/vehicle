{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}

{-# OPTIONS_GHC -Wno-orphans #-}

module Vehicle.Frontend.Parse
  ( parseText
  , parseFile
  ) where

import Data.Text (Text)
import qualified Data.Text.IO as T
import System.Exit (exitFailure)

import Vehicle.Frontend.Abs as B
import Vehicle.Frontend.Layout (resolveLayout)
import Vehicle.Frontend.Lex as L (Token)
import Vehicle.Frontend.Par (pProg, myLexer)

import qualified Vehicle.Frontend.AST as V
import Vehicle.Frontend.AST.Utils (annotation)

import Vehicle.Prelude (K(..), KnownSort, Token(..), tkSymbol, IsToken)
import Vehicle.Prelude.Provenance (Provenance (..), tkProvenance, HasProvenance(..))


--------------------------------------------------------------------------------
-- * Type synonyms

type PTree = V.Tree (K Provenance)
type PKind = V.Kind (K Provenance)
type PType = V.Type (K Provenance)
type PTArg = V.TArg (K Provenance)
type PExpr = V.Expr (K Provenance)
type PEArg = V.EArg (K Provenance)
type PDecl = V.Decl (K Provenance)
type PProg = V.Prog (K Provenance)

--------------------------------------------------------------------------------
-- Parsing

parseText :: Text -> Either String PProg
parseText = fmap conv . runParser True pProg

parseFile :: FilePath -> IO PProg
parseFile file = do
  contents <- T.readFile file
  case parseText contents of
    Left err -> do putStrLn err; exitFailure
    Right ast -> return ast


type Parser a = [L.Token] -> Either String a

runParser :: Bool -> Parser a -> Text -> Either String a
runParser topLevel p t = p (runLexer topLevel t)

runLexer :: Bool -> Text -> [L.Token]
runLexer topLevel = resolveLayout topLevel . myLexer

--------------------------------------------------------------------------------
-- Conversion from BNFC AST
--
-- We convert from the simple AST generated automatically by BNFC to our
-- more complicated internal version of the AST which allows us to annotate
-- terms with sort-dependent types.
--
-- While doing this, we extract the positions from the tokens generated by BNFC
-- and convert them into `Provenance` annotations.

-- * Provenance

-- | A slightly shorter name for `tkProvenance`
tkProv :: IsToken a => a -> Provenance
tkProv = tkProvenance

instance KnownSort sort => HasProvenance (V.Tree (K Provenance) sort) where
  prov = unK . annotation

-- * Conversion

class Convert vf vc where
  conv :: vf -> vc

instance Convert B.Kind PKind where
  conv (B.KApp k1 k2)    = op2 V.KApp  mempty (conv k1) (conv k2)
  conv (B.KFun k1 tk k2) = op2 V.KFun  (tkProv tk) (conv k1) (conv k2)
  conv (B.KType tk)      = op0 V.KType (tkProv tk)
  conv (B.KDim tk)       = op0 V.KDim  (tkProv tk)
  conv (B.KList tk)      = op0 V.KList (tkProv tk)

instance Convert B.Type PType where
  conv (B.TForall tk1 ns tk2 t)   = op2 V.TForall (tkProv tk1 <> tkProv tk2) (map conv ns) (conv t)
  conv (B.TApp t1 t2)             = op2 V.TApp mempty (conv t1) (conv t2)
  conv (B.TVar n)                 = V.TVar (K (tkProv n)) (tkSymbol n)
  conv (B.TFun t1 tk t2)          = op2 V.TFun (tkProv tk) (conv t1) (conv t2)
  conv (B.TBool tk)               = op0 V.TBool (tkProv tk)
  conv (B.TProp tk)               = op0 V.TProp (tkProv tk)
  conv (B.TReal tk)               = op0 V.TReal (tkProv tk)
  conv (B.TInt tk)                = op0 V.TInt (tkProv tk)
  conv (B.TList tk)               = op0 V.TList (tkProv tk)
  conv (B.TTensor tk)             = op0 V.TTensor (tkProv tk)
  conv (B.TAdd t1 tk t2)          = op2 V.TAdd (tkProv tk) (conv t1) (conv t2)
  conv (B.TLitDim i)              = V.TLitDim mempty i
  conv (B.TCons t1 tk t2)         = op2 V.TCons (tkProv tk) (conv t1) (conv t2)
  conv (B.TLitDimList tk1 ts tk2) = op1 V.TLitDimList (tkProv tk1 <> tkProv tk2) (map conv ts)

instance Convert Name PTArg where
  conv n = V.TArg (K (tkProv n)) (tkSymbol n)

instance Convert B.Expr PExpr where
  conv (B.EAnn e tk t)              = op2 V.EAnn (tkProv tk) (conv e) (conv t)
  conv (B.ELet ds e)                = op2 V.ELet mempty (map conv ds) (conv e)
  conv (B.ELam tk1 ns tk2 e)        = op2 V.ELam (tkProv tk1 <> tkProv tk2) (map conv ns) (conv e)
  conv (B.EApp e1 e2)               = op2 V.EApp mempty (conv e1) (conv e2)
  conv (B.EVar n)                   = V.EVar (K (tkProv n)) (tkSymbol n)
  conv (B.ETyApp e t)               = op2 V.ETyApp mempty (conv e) (conv t)
  conv (B.ETyLam tk1 ns tk2 e)      = op2 V.ETyLam (tkProv tk1 <> tkProv tk2) (map conv ns) (conv e)
  conv (B.EIf tk1 e1 tk2 e2 tk3 e3) = op3 V.EIf (tkProv tk1 <> tkProv tk2 <> tkProv tk3) (conv e1) (conv e2) (conv e3)
  conv (B.EImpl e1 tk e2)           = op2 V.EImpl (tkProv tk) (conv e1) (conv e2)
  conv (B.EAnd e1 tk e2)            = op2 V.EAnd (tkProv tk) (conv e1) (conv e2)
  conv (B.EOr e1 tk e2)             = op2 V.EOr (tkProv tk) (conv e1) (conv e2)
  conv (B.ENot tk e)                = op1 V.ENot (tkProv tk) (conv e)
  conv (B.ETrue tk)                 = op0 V.ETrue (tkProv tk)
  conv (B.EFalse tk)                = op0 V.EFalse (tkProv tk)
  conv (B.EEq e1 tk e2)             = op2 V.EEq (tkProv tk) (conv e1) (conv e2)
  conv (B.ENeq e1 tk e2)            = op2 V.ENeq (tkProv tk) (conv e1) (conv e2)
  conv (B.ELe e1 tk e2)             = op2 V.ELe (tkProv tk) (conv e1) (conv e2)
  conv (B.ELt e1 tk e2)             = op2 V.ELt (tkProv tk) (conv e1) (conv e2)
  conv (B.EGe e1 tk e2)             = op2 V.EGe (tkProv tk) (conv e1) (conv e2)
  conv (B.EGt e1 tk e2)             = op2 V.EGt (tkProv tk) (conv e1) (conv e2)
  conv (B.EMul e1 tk e2)            = op2 V.EMul (tkProv tk) (conv e1) (conv e2)
  conv (B.EDiv e1 tk e2)            = op2 V.EDiv (tkProv tk) (conv e1) (conv e2)
  conv (B.EAdd e1 tk e2)            = op2 V.EAdd (tkProv tk) (conv e1) (conv e2)
  conv (B.ESub e1 tk e2)            = op2 V.ESub (tkProv tk) (conv e1) (conv e2)
  conv (B.ENeg tk e)                = op1 V.ENeg (tkProv tk) (conv e)
  conv (B.ELitInt i)                = V.ELitInt mempty i
  conv (B.ELitReal d)               = V.ELitReal mempty d
  conv (B.ECons e1 tk e2)           = op2 V.ECons (tkProv tk) (conv e1) (conv e2)
  conv (B.EAt e1 tk e2)             = op2 V.EAt (tkProv tk) (conv e1) (conv e2)
  conv (B.EAll tk)                  = op0 V.EAll (tkProv tk)
  conv (B.EAny tk)                  = op0 V.EAny (tkProv tk)
  conv (B.ELitSeq tk1 es tk2)       = op1 V.ELitSeq (tkProv tk1 <> tkProv tk2) (map conv es)

instance Convert Name PEArg where
  conv n = V.EArg (K (tkProv n)) (tkSymbol n)

instance Convert B.Decl PDecl where
  conv (B.DeclNetw n tk t)   = op2 V.DeclNetw (tkProv tk) (conv n) (conv t)
  conv (B.DeclData n tk t)   = op2 V.DeclData (tkProv tk) (conv n) (conv t)
  conv (B.DefType n ns t)    = op3 V.DefType mempty (conv n) (map conv ns) (conv t)
  conv (B.DefFunType n tk t) = op2 V.DefFunType (tkProv tk) (conv n) (conv t)
  conv (B.DefFunExpr n ns e) = op3 V.DefFunExpr mempty (conv n) (map conv ns) (conv e)

instance Convert B.Prog PProg where
  conv (Main ds) = V.Main mempty (map conv ds)

op0 :: (K Provenance sort -> PTree sort)
    -> Provenance -> PTree sort
op0 mk p = mk (K p)

op1 :: (HasProvenance a)
    => (K Provenance sort -> a -> PTree sort)
    -> Provenance -> a -> PTree sort
op1 mk p t = mk (K (p <> prov t)) t

op2 :: (KnownSort sort, HasProvenance a, HasProvenance b)
    => (K Provenance sort -> a -> b -> PTree sort)
    -> Provenance -> a -> b -> PTree sort
op2 mk p t1 t2 = mk (K (p <> prov t1 <> prov t2)) t1 t2

op3 :: (KnownSort sort, HasProvenance a, HasProvenance b, HasProvenance c)
    => (K Provenance sort -> a -> b -> c -> PTree sort)
    -> Provenance -> a -> b -> c -> PTree sort
op3 mk p t1 t2 t3 = mk (K (p <> prov t1 <> prov t2 <> prov t3)) t1 t2 t3