{-# LANGUAGE ConstraintKinds  #-}
{-# LANGUAGE FlexibleContexts #-}

module Vehicle.Frontend.Type
  ( module Vehicle.Frontend.Abs
  , Position
  , Token(..)
  , tkName
  , tkPos
  , IsToken
  , tkEq
  , isDefFun
  , declName
  ) where

import Data.Coerce (Coercible, coerce)
import Data.Text (Text)
import Vehicle.Frontend.Abs

-- |Positions in BNFC generated grammars are represented by a pair of a line
--  number and a column number.
type Position = (Int, Int)

-- |Position tokens in BNFC generated grammars are represented by a pair of a
-- position and the text token.
newtype Token = Tk (Position, Text)
  deriving (Eq, Ord, Show, Read)

tkName :: Token -> Text
tkName (Tk (_p, tk)) = tk

tkPos :: Token -> Position
tkPos (Tk (p, _tk)) = p

-- |Constraint for newtypes which are /position tokens/. Depends on the fact
--  that any /position token/ generated by BNFC with @--text@ will be a newtype
--  wrapping '(Position, Text)', and hence all are coercible to it. This breaks
--  if the @--text@ option is not passed, or if the token is not marked with the
--  @position@ keyword.
type IsToken a = Coercible a Token

-- |Compare the text portion of any two position tokens.
tkEq :: IsToken a => a -> a -> Bool
tkEq x y = tkName (coerce x) == tkName (coerce y)


-- |Check if a declaration is a network declaration.
isDefFun :: Decl -> Bool
isDefFun (DefFunType _name _elemOf _typ) = True
isDefFun (DefFunExpr _name _args _exp) = True
isDefFun _ = False

-- |Get the name for any declaration.
declName :: Decl -> Name
declName (DeclNetw name _elemOf _typ) = name
declName (DeclData name _elemOf _typ) = name
declName (DefType name _args _type) = name
declName (DefFunType name _elemOf _typ) = name
declName (DefFunExpr name _args _exp) = name
