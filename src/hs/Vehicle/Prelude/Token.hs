{-# LANGUAGE ConstraintKinds  #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE PatternSynonyms  #-}

module Vehicle.Prelude.Token
  ( Position
  , Token(..)
  , IsToken
  , toToken
  , fromToken
  , tkText
  , tkPos
  , tkEq
  , tkUpdateText
  ) where

import Data.Function (on)
import Data.Coerce (Coercible, coerce)
import Data.Text (Text)

-- |Positions in BNFC generated grammars are represented by a pair of a line
--  number and a column number.
type Position = (Int, Int)

-- |Position tokens in BNFC generated grammars are represented by a pair of a
-- position and the text token.
newtype Token = Tk (Position, Text)
  deriving (Eq, Ord, Show, Read)

pattern Token :: Position -> Text -> Token
pattern Token{pos,text} = Tk (pos,text)

-- |Constraint for newtypes which are /position tokens/. Depends on the fact
--  that any /position token/ generated by BNFC with @--text@ will be a newtype
--  wrapping '(Position, Text)', and hence all are coercible to it. This breaks
--  if the @--text@ option is not passed, or if the token is not marked with the
--  @position@ keyword.
type IsToken a = Coercible a Token

-- |Convert from 'Token' to an arbitrary newtype via 'Coercible'.
toToken :: IsToken a => a -> Token
toToken = coerce

-- |Convert to 'Token' from an arbitrary newtype via 'Coercible'.
fromToken :: IsToken a => Token -> a
fromToken = coerce

-- |Get the 'Text' field of a 'Token'.
tkText :: IsToken a => a -> Text
tkText = text . toToken

-- |Get the 'Position' field of a 'Token'.
tkPos :: IsToken a => a -> Position
tkPos = pos . toToken

-- |Compare the text portion of any two position tokens.
tkEq :: IsToken a => a -> a -> Bool
tkEq = (==) `on` toToken

-- |Change name of a token.
tkUpdateText :: IsToken a => Text -> a -> a
tkUpdateText txt tk = fromToken (Token { pos = tkPos tk, text = txt})
