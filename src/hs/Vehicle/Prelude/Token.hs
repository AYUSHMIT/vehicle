{-# LANGUAGE ConstraintKinds  #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE PatternSynonyms  #-}

module Vehicle.Prelude.Token
  ( Symbol
  , Position
  , line
  , column
  , Token(..)
  , IsToken
  , toToken
  , fromToken
  , tkSymbol
  , tkPosition
  , tkLength
  , tkRange
  , tkEq
  , tkUpdateText
  ) where

import           Data.Range (Range(..), (+=+))
import           Data.Function (on)
import           Data.Coerce (Coercible, coerce)
import           Data.Text (Text)
import qualified Data.Text as T


-- |Symbols in BNFC generated grammars are represented by |Text|.
type Symbol = Text

-- |Positions in BNFC generated grammars are represented by a pair of a line
--  number and a column number.
type Position = (Int, Int)

line :: Position -> Int
line = fst

column :: Position -> Int
column = snd

-- |Position tokens in BNFC generated grammars are represented by a pair of a
-- position and the text token.
newtype Token = Tk (Position, Symbol)
  deriving (Eq, Ord, Show, Read)

pattern Token :: Position -> Symbol -> Token
pattern Token{pos,sym} = Tk (pos,sym)

-- |Constraint for newtypes which are /position tokens/. Depends on the fact
--  that any /position token/ generated by BNFC with @--text@ will be a newtype
--  wrapping '(Position, Symbol)', and hence all are coercible to it. This breaks
--  if the @--text@ option is not passed, or if the token is not marked with the
--  @position@ keyword.
type IsToken a = Coercible a Token

-- |Convert from 'Token' to an arbitrary newtype via 'Coercible'.
toToken :: IsToken a => a -> Token
toToken = coerce

-- |Convert to 'Token' from an arbitrary newtype via 'Coercible'.
fromToken :: IsToken a => Token -> a
fromToken = coerce

-- |Get the symbol of a token.
tkSymbol :: IsToken a => a -> Symbol
tkSymbol = sym. toToken

-- |Get the starting position of a token.
tkPosition :: IsToken a => a -> Position
tkPosition = pos . toToken

-- |Get the length of a token.
tkLength :: IsToken a => a -> Int
tkLength = T.length . tkSymbol

-- |Get the starting and ending position of a token.
tkRange :: IsToken a => a -> [Range Position]
tkRange tk = [start +=+ end]
  where
    start = tkPosition tk
    end   = (line start, column start + tkLength tk)

-- |Compare the text portion of any two position tokens.
tkEq :: IsToken a => a -> a -> Bool
tkEq = (==) `on` toToken

-- |Change name of a token.
tkUpdateText :: IsToken a => Text -> a -> a
tkUpdateText txt tk = fromToken (Token { pos = tkPosition tk, sym = txt})
