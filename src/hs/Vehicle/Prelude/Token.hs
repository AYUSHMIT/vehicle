{-# LANGUAGE ConstraintKinds  #-}
{-# LANGUAGE FlexibleContexts #-}

module Vehicle.Prelude.Token
  ( Position
  , Token(..)
  , IsToken
  , toToken
  , fromToken
  , tkName
  , tkPos
  , tkEq
  , tkRename
  ) where

import Data.Coerce (Coercible, coerce)
import Data.Text (Text)

-- |Positions in BNFC generated grammars are represented by a pair of a line
--  number and a column number.
type Position = (Int, Int)

-- |Position tokens in BNFC generated grammars are represented by a pair of a
-- position and the text token.
newtype Token = Tk (Position, Text)
  deriving (Eq, Ord, Show, Read)

-- |Constraint for newtypes which are /position tokens/. Depends on the fact
--  that any /position token/ generated by BNFC with @--text@ will be a newtype
--  wrapping '(Position, Text)', and hence all are coercible to it. This breaks
--  if the @--text@ option is not passed, or if the token is not marked with the
--  @position@ keyword.
type IsToken a = Coercible a Token

-- |Convert from 'Token' to an arbitrary newtype via 'Coercible'.
toToken :: IsToken a => a -> Token
toToken = coerce

-- |Convert to 'Token' from an arbitrary newtype via 'Coercible'.
fromToken :: IsToken a => Token -> a
fromToken = coerce

-- |Get the 'Text' field of a 'Token'.
tkName :: IsToken a => a -> Text
tkName tk = case toToken tk of Tk (_p, n) -> n

-- |Get the 'Position' field of a 'Token'.
tkPos :: IsToken a => a -> Position
tkPos tk = case toToken tk of Tk (p, _n) -> p

-- |Compare the text portion of any two position tokens.
tkEq :: IsToken a => a -> a -> Bool
tkEq x y = tkName (toToken x) == tkName (toToken y)

-- |Change name of a token.
tkRename :: IsToken a => Text -> a -> a
tkRename n tk = fromToken $ Tk (tkPos tk, n)
