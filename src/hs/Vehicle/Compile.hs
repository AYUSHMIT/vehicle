module Vehicle.Compile
  ( CompileOptions(..)
  , compile
  ) where

import Paths_vehicle qualified as VehiclePath (version)

import Control.Monad.Except (ExceptT, runExceptT)
import Data.Text as T (Text, pack)
import Data.Text.IO qualified as TIO
import Data.Version (Version, makeVersion)
import System.Exit (exitFailure)

import Vehicle.Prelude
import Vehicle.Language.AST qualified as V
import Vehicle.Compile.Error.Meaningful
import Vehicle.Compile.Parse qualified as V
import Vehicle.Compile.Elaborate.Frontend as Frontend
import Vehicle.Compile.Scope qualified as V
import Vehicle.Compile.Type qualified as V
import Vehicle.Compile.Normalise qualified as V (normalise)

import Vehicle.Compile.Backend.SMTLib (compileToSMTLib, SMTDoc(..))
import Vehicle.Compile.Backend.VNNLib (compileToVNNLib, VNNLibDoc(..))
import Vehicle.Compile.Backend.Agda (compileToAgda, AgdaOptions(..))

data CompileOptions = CompileOptions
  { inputFile      :: FilePath
  , outputFile     :: Maybe FilePath
  , outputTarget   :: OutputTarget
  , moduleName     :: String
  } deriving (Show)

compile :: LogFilePath -> CompileOptions -> IO ()
compile logFile opts@CompileOptions{..} = do

  -- Read file, parse and elaborate to core if necessary
  contents <- TIO.readFile inputFile
  rawProg  <- parseAndElab logFile contents

  -- Scope check, type check etc.
  scopedCoreProg <- fromLoggedEitherIO logFile $ V.scopeCheck rawProg
  typedCoreProg  <- fromLoggedEitherIO logFile $ V.typeCheck scopedCoreProg

  -- Compile to requested backend
  case outputTarget of
    target@(ITP itp) -> do
      case itp of
        Agda -> do
          let agdaOptions = AgdaOptions "TODO_projectFile" [T.pack moduleName] mempty
          agdaDoc <- fromLoggedEitherIO logFile $ compileToAgda agdaOptions typedCoreProg
          writeResultToFile opts target agdaDoc

    (Verifier verifier) -> do
      normProg <- fromLoggedEitherIO logFile $ V.normalise typedCoreProg
      case verifier of
        SMTLib -> toSMTLib logFile opts normProg
        VNNLib -> toVNNLib logFile opts normProg

parseAndElab :: LogFilePath -> Text -> IO V.InputProg
parseAndElab logFile contents = do
  progVF <- fromEitherIO (V.parseVehicle contents)
  fromLoggedEitherIO logFile $ Frontend.runElab progVF

fromEitherIO :: MeaningfulError e => Either e a -> IO a
fromEitherIO (Left err) = do print $ details err; exitFailure
fromEitherIO (Right x)  = return x

fromLoggedEitherIO :: MeaningfulError e => LogFilePath -> ExceptT e Logger a -> IO a
fromLoggedEitherIO logFile x = fromEitherIO =<< fromLoggedIO logFile (runExceptT x)

fromLoggedIO :: LogFilePath -> Logger a -> IO a
fromLoggedIO Nothing        logger = return $ discardLogger logger
fromLoggedIO (Just logFile) logger = flushLogs logFile logger

writeResultToFile :: CompileOptions -> OutputTarget -> Doc a -> IO ()
writeResultToFile CompileOptions{..} target doc = do
  let fileHeader = makefileHeader target
  let outputText = layoutAsText (fileHeader <> line <> line <> doc)
  case outputFile of
    Nothing             -> TIO.putStrLn outputText
    Just outputFilePath -> TIO.writeFile outputFilePath outputText

toSMTLib :: LogFilePath -> CompileOptions -> V.CheckedProg -> IO ()
toSMTLib logFile options prog = do
  propertyDocs <- fromLoggedEitherIO logFile (compileToSMTLib prog)
  mapM_ (\doc -> writeResultToFile options (Verifier SMTLib) (text doc)) propertyDocs

toVNNLib :: LogFilePath -> CompileOptions -> V.CheckedProg -> IO ()
toVNNLib logFile options prog = do
  propertyDocs <- fromLoggedEitherIO logFile (compileToVNNLib prog)
  mapM_ (\doc -> writeResultToFile options (Verifier VNNLib) (text (smtDoc doc))) propertyDocs

-- |Generate the file header given the token used to start comments in the
-- target language
makefileHeader :: OutputTarget -> Doc a
makefileHeader target = vsep $
  map (commentTokenOf target <+>)
    [ "WARNING: This file was generated automatically by Vehicle"
    , "and should not be modified manually!"
    , "Metadata"
    , " -" <+> pretty (show target) <> " version:" <+> targetVersion
    , " - AISEC version:" <+> pretty VehiclePath.version
    , " - Time generated: ???"
    ]
  where targetVersion = maybe "N/A" pretty (versionOf target)

versionOf :: OutputTarget -> Maybe Version
versionOf target = case target of
  Verifier VNNLib        -> Nothing
  Verifier SMTLib        -> Nothing
  ITP Agda               -> Just $ makeVersion [2,6,2]

commentTokenOf :: OutputTarget -> Doc a
commentTokenOf = \case
  Verifier VNNLib        -> ";"
  Verifier SMTLib        -> ";"
  ITP Agda               -> "--"