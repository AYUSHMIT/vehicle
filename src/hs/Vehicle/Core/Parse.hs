{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE DuplicateRecordFields #-}

{-# OPTIONS_GHC -Wno-orphans #-}

{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeFamilies #-}
module Vehicle.Core.Parse
  ( parseText
  , parseFile
  , ParseError(..)
  ) where

import Control.Monad.Except (MonadError(..))
import Data.Text (Text, pack)
import Data.Text.IO qualified as T
import Data.List.NonEmpty (NonEmpty(..))
import Prettyprinter ( (<+>), pretty )
import System.Exit (exitFailure)

import Vehicle.Core.Abs as B
import Vehicle.Core.Par (pProg, myLexer)
import Vehicle.Core.AST as V hiding (Name)
import Vehicle.Prelude
import Vehicle.Error

--------------------------------------------------------------------------------
-- Parsing

parseText :: Text -> Either ParseError V.InputProg
parseText txt = case pProg (myLexer txt) of
  Left err1      -> Left $ BNFCParseError err1
  Right bnfcProg -> case conv bnfcProg of
    Left  err2 -> Left  err2
    Right prog -> Right prog

-- Used in both application and testing which is why it lives here.
parseFile :: FilePath -> IO V.InputProg
parseFile file = do
  contents <- T.readFile file
  case parseText contents of
    Left err -> do print (details err); exitFailure
    Right ast -> return ast

--------------------------------------------------------------------------------
-- Errors

-- |Type of errors thrown when parsing.
data ParseError
  = UnknownBuiltin Token
  | MissingVariables
  | BNFCParseError String

instance MeaningfulError ParseError where
  details (UnknownBuiltin tk) = UError $ UserError
    { problem    = "Unknown symbol" <+> pretty (tkSymbol tk)
    , provenance = tkProvenance tk
    , fix        = "Please consult the documentation for a description of Vehicle syntax"
    }

  -- TODO improve this error message. The problem is that there are no tokens
  -- in the Core language grammar and therefore we can't extract them.
  details MissingVariables = UError $ UserError
    { problem    = "Expected at least one variable/declaration"
    , provenance = mempty
    , fix        = "Unknown"
    }

  -- TODO need to revamp this error, BNFC must provide some more
  -- information than a simple string surely?
  details (BNFCParseError text) = EError $ ExternalError (pack text)

--------------------------------------------------------------------------------
-- Conversion from BNFC AST
--
-- We convert from the simple AST generated automatically by BNFC to our
-- more complicated internal version of the AST which allows us to annotate
-- terms with sort-dependent types.
--
-- While doing this, we
--
--   1) extract the positions from the tokens generated by BNFC and convert them
--   into `Provenance` annotations.
--
--   2) convert the builtin strings into `Builtin`s

-- * Conversion

class Convert vf vc where
  conv :: MonadParse m => vf -> m vc

type MonadParse m = MonadError ParseError m

--------------------------------------------------------------------------------
-- Builtins

unKindBuiltin :: KindBuiltin -> B.Builtin
unKindBuiltin (MkKindBuiltin b) = b

unTypeBuiltin :: TypeBuiltin -> B.Builtin
unTypeBuiltin (MkTypeBuiltin b) = b

unExprBuiltin :: ExprBuiltin -> B.Builtin
unExprBuiltin (MkExprBuiltin b) = b

instance HasProvenance KindBuiltin where
  prov = tkProvenance . unKindBuiltin

instance HasProvenance TypeBuiltin where
  prov = tkProvenance . unTypeBuiltin

instance HasProvenance ExprBuiltin where
  prov = tkProvenance . unExprBuiltin

instance Convert KindBuiltin (V.Builtin 'KIND) where
  conv = lookupBuiltin . unKindBuiltin

instance Convert TypeBuiltin (V.Builtin 'TYPE) where
  conv = lookupBuiltin . unTypeBuiltin

instance Convert ExprBuiltin (V.Builtin 'EXPR) where
  conv = lookupBuiltin . unExprBuiltin

lookupBuiltin
  :: (MonadParse m, IsToken tok, KnownSort sort, sort `In` ['KIND, 'TYPE, 'EXPR])
  => tok
  -> m (V.Builtin sort)
lookupBuiltin tk = case builtinFromSymbol (tkSymbol tk) of
  Nothing -> throwError $ UnknownBuiltin $ toToken tk
  Just v -> return v

--------------------------------------------------------------------------------
-- AST conversion

instance Convert B.Kind V.InputKind where
  conv = \case
    B.KApp k1 k2 -> op2 V.KApp <$> conv k1 <*> conv k2
    B.KCon c     -> V.KCon (K (prov c)) <$> conv c

instance Convert B.Type V.InputType where
  conv = \case
    B.TForall n t    -> op2 V.TForall <$> conv n <*> conv t
    B.TApp t1 t2     -> op2 V.TApp <$> conv t1 <*> conv t2
    B.TVar n         -> conv n
    B.TCon c         -> V.TCon (K (prov c)) <$> conv c
    B.TLitDim d      -> return $ V.TLitDim mempty d
    B.TLitDimList ts -> op1 V.TLitDimList <$> traverseNonEmpty ts

instance Convert B.TypeName V.InputType where
  conv (MkTypeName n) = return $ V.TVar (K (tkProvenance n)) (K (tkSymbol n))

instance Convert B.TypeBinder V.InputTArg where
  conv (MkTypeBinder n) = return $ V.TArg (K (tkProvenance n)) (K (tkSymbol n))

instance Convert B.Expr V.InputExpr where
  conv = \case
    B.EAnn e t     -> op2 V.EAnn <$> conv e <*> conv t
    B.ELet n e1 e2 -> op3 V.ELet <$> conv n <*> conv e1 <*> conv e2
    B.ELam n e     -> op2 V.ELam <$> conv n <*> conv e
    B.EApp e1 e2   -> op2 V.EApp <$> conv e1 <*> conv e2
    B.EVar n       -> conv n
    B.ETyApp e t   -> op2 V.ETyApp <$> conv e <*> conv t
    B.ETyLam n e   -> op2 V.ETyLam <$> conv n <*> conv e
    B.ECon c       -> V.ECon (K (prov c)) <$> conv c
    B.ELitInt i    -> return $ V.ELitInt mempty i
    B.ELitReal r   -> return $ V.ELitReal mempty r
    B.ELitSeq es   -> op1 V.ELitSeq <$> traverseNonEmpty es

instance Convert B.ExprName V.InputExpr where
  conv (MkExprName n) = return $ V.EVar (K (tkProvenance n)) (K (tkSymbol n))

instance Convert B.ExprBinder V.InputEArg where
  conv (MkExprBinder n) = return $ V.EArg (K (tkProvenance n)) (K (tkSymbol n))

instance Convert B.Decl V.InputDecl where
  conv = \case
    B.DeclNetw n t   -> op2 V.DeclNetw <$> conv n <*> conv t
    B.DeclData n t   -> op2 V.DeclData <$> conv n <*> conv t
    B.DefType n ns t -> op3 V.DefType  <$> conv n <*> traverse conv ns <*> conv t
    B.DefFun n t e   -> op3 V.DefFun   <$> conv n <*> conv t <*> conv e

instance Convert B.Prog V.InputProg where
  conv (B.Main ds) = op1 V.Main <$> traverseNonEmpty ds

op1 :: (HasProvenance a)
    => (K Provenance sort -> a -> V.InputTree sort)
    -> a -> V.InputTree sort
op1 mk t = mk (K (prov t)) t

op2 :: (KnownSort sort, HasProvenance a, HasProvenance b)
    => (K Provenance sort -> a -> b -> V.InputTree sort)
    -> a -> b -> V.InputTree sort
op2 mk t1 t2 = mk (K (prov t1 <> prov t2)) t1 t2

op3 :: (KnownSort sort, HasProvenance a, HasProvenance b, HasProvenance c)
    => (K Provenance sort -> a -> b -> c -> V.InputTree sort)
    -> a -> b -> c -> V.InputTree sort
op3 mk t1 t2 t3 = mk (K (prov t1 <> prov t2 <> prov t3)) t1 t2 t3

-- A traversal that checks that the list is non-empty. In theory this would be
-- much nicer if the parser could handle this automatically
-- (see https://github.com/BNFC/bnfc/issues/371)
traverseNonEmpty :: (MonadParse m , Convert a b)
                 => [a] -> m (NonEmpty b)
traverseNonEmpty []       = throwError MissingVariables
traverseNonEmpty (x : xs) = traverse conv (x :| xs)