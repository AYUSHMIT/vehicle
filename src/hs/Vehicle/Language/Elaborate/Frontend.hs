{-# OPTIONS_GHC -Wno-orphans #-}

module Vehicle.Language.Elaborate.Frontend
  ( runElab
  ) where

import Control.Monad.Except (MonadError, throwError)
import Data.Bitraversable (bitraverse)
import Data.List.NonEmpty (NonEmpty(..))
import Data.Foldable (fold)
import Data.List.NonEmpty qualified as NonEmpty (groupBy1, head, toList)

import Vehicle.Frontend.Abs qualified as B

import Vehicle.Prelude
import Vehicle.Language.AST qualified as V
import Vehicle.Language.Sugar

runElab :: (MonadLogger m, MonadError ElabError m) => B.Prog -> m V.InputProg
runElab = elab

--------------------------------------------------------------------------------
-- Errors

data ElabError
  = MissingDefFunType    Provenance Symbol
  | MissingDefFunExpr    Provenance Symbol
  | DuplicateName        (NonEmpty Provenance) Symbol
  | MissingVariables     Provenance Symbol

instance MeaningfulError ElabError where
  details (MissingDefFunType p name) = UError $ UserError
    { problem    = "missing type for the declaration" <+> squotes (pretty name)
    , provenance = p
    , fix        = "add a type for the declaration, e.g."
                   <> line <> line
                   <> "addOne :: Int -> Int    <-----   type declaration" <> line
                   <> "addOne x = x + 1"
    }

  details (MissingDefFunExpr p name) = UError $ UserError
    { problem    = "missing definition for the declaration" <+> squotes (pretty name)
    , provenance = p
    , fix        = "add a definition for the declaration, e.g."
                   <> line <> line
                   <> "addOne :: Int -> Int" <> line
                   <> "addOne x = x + 1     <-----   declaration definition"
    }

  details (DuplicateName p name) = UError $ UserError
    { problem    = "multiple definitions found with the name" <+> squotes (pretty name)
    , provenance = fold p
    , fix        = "remove or rename the duplicate definitions"
    }

  details (MissingVariables p symbol) = UError $ UserError
    { problem    = "expected at least one variable name after" <+> squotes (pretty symbol)
    , provenance = p
    , fix        = "add one or more names after" <+> squotes (pretty symbol)
    }

--------------------------------------------------------------------------------
-- Conversion from BNFC AST
--
-- We elabert from the simple AST generated automatically by BNFC to our
-- more complicated internal version of the AST which allows us to annotate
-- terms with sort-dependent types.
--
-- While doing this we:
--  1. extract the positions from the tokens generated by BNFC and elabert them
--     into `Provenance` annotations.
--  2. combine function types and expressions into a single AST node

-- | Constraint for the monad stack used by the elaborator.
type MonadElab m = MonadError ElabError m

-- * Provenance

-- | A slightly shorter name for `tkProvenance`
tkProv :: IsToken a => a -> Provenance
tkProv = tkProvenance

-- * Elaboration

class Elab vf vc where
  elab :: MonadElab m => vf -> m vc

instance Elab B.Prog V.InputProg where
  elab (B.Main decls) = V.Main <$> groupDecls decls

-- |Elaborate declarations.
instance Elab (NonEmpty B.Decl) V.InputDecl where
  elab = \case
    -- Elaborate a network declaration.
    (B.DeclNetw n _tk t :| []) -> V.DeclNetw (tkProv n) <$> elab n <*> elab t

    -- Elaborate a dataset declaration.
    (B.DeclData n _tk t :| []) -> V.DeclData (tkProv n) <$> elab n <*> elab t

    -- Elaborate a type definition.
    (B.DefType n bs e :| []) -> do
      unfoldDefType (tkProv n) <$> elab n <*> traverse elab bs <*> elab e

    -- Elaborate a function definition.
    (B.DefFunType n1 _tk t  :| [B.DefFunExpr _n2 bs e]) ->
      unfoldDefFun (tkProv n1) <$> elab n1 <*> elab t <*> traverse elab bs <*> elab e

    -- Why did you write the signature AFTER the function?
    (e1@B.DefFunExpr {} :| [e2@B.DefFunType {}]) ->
      elab (e2 :| [e1])

    -- Missing type or expression declaration.
    (B.DefFunType n _tk _t :| []) ->
      throwError $ MissingDefFunExpr (tkProv n) (tkSymbol n)

    (B.DefFunExpr n _ns _e :| []) ->
      throwError $ MissingDefFunType (tkProv n) (tkSymbol n)

    -- Multiple type of expression declarations with the same n.
    ds ->
      throwError $ DuplicateName provs symbol
        where
          symbol = tkSymbol $ declName $ NonEmpty.head ds
          provs  = fmap (tkProv . declName) ds

instance Elab B.Expr V.InputExpr where
  elab = \case
    B.Type l                  -> return $ V.Type (fromIntegral l)
    B.Var  n                  -> return $ V.Var  (tkProv n) (V.User $ tkSymbol n)
    B.Hole n                  -> return $ V.Hole (tkProv n) (tkSymbol n)
    B.Literal l               -> elab l
    B.TypeC   tc              -> elab tc

    B.Ann e tk t              -> op2 V.Ann (tkProv tk) (elab e) (elab t)
    B.Fun t1 tk t2            -> op2 V.Pi  (tkProv tk) (elabFunInputType t1) (elab t2)
    B.Seq tk1 es _tk2         -> op1 V.Seq (tkProv tk1) (traverse elab es)

    B.App e1 e2               -> elabApp e1 e2
    -- It is really bad not to have provenance for let tokens here, see issue #6
    B.Let ds e                -> unfoldLet mempty <$> bitraverse (traverse elab) elab (ds, e)
    B.Forall tk1 ns _tk2 t    -> do checkNonEmpty tk1 ns; unfoldForall (tkProv tk1) <$> elabBindersAndBody ns t
    B.Lam tk1 ns _tk2 e       -> do checkNonEmpty tk1 ns; unfoldLam    (tkProv tk1) <$> elabBindersAndBody ns e

    B.Every   tk1 ns    _tk2 e  -> elabQuantifier   tk1 V.All ns e
    B.Some    tk1 ns    _tk2 e  -> elabQuantifier   tk1 V.Any ns e
    B.EveryIn tk1 ns e1 _tk2 e2 -> elabQuantifierIn tk1 V.All ns e1 e2
    B.SomeIn  tk1 ns e1 _tk2 e2 -> elabQuantifierIn tk1 V.Any ns e1 e2

    B.Bool tk                 -> builtin V.Bool   (tkProv tk) []
    B.Prop tk                 -> builtin V.Prop   (tkProv tk) []
    B.Real tk                 -> builtin V.Real   (tkProv tk) []
    B.Int tk                  -> builtin V.Int    (tkProv tk) []
    B.Nat tk                  -> builtin V.Nat    (tkProv tk) []
    B.List tk t               -> builtin V.List   (tkProv tk) [t]
    B.Tensor tk t1 t2         -> builtin V.Tensor (tkProv tk) [t1, t2]

    B.If tk1 e1 _ e2 _ e3     -> builtin V.If   (tkProv tk1)[e1, e2, e3]
    B.Impl e1 tk e2           -> builtin V.Impl (tkProv tk) [e1, e2]
    B.And e1 tk e2            -> builtin V.And  (tkProv tk) [e1, e2]
    B.Or e1 tk e2             -> builtin V.Or   (tkProv tk) [e1, e2]
    B.Not tk e                -> builtin V.Not  (tkProv tk) [e]

    B.Eq e1 tk e2             -> builtin V.Eq           (tkProv tk) [e1, e2]
    B.Neq e1 tk e2            -> builtin V.Neq          (tkProv tk) [e1, e2]
    B.Le e1 tk e2             -> builtin (V.Order V.Le) (tkProv tk) [e1, e2]
    B.Lt e1 tk e2             -> builtin (V.Order V.Lt) (tkProv tk) [e1, e2]
    B.Ge e1 tk e2             -> builtin (V.Order V.Ge) (tkProv tk) [e1, e2]
    B.Gt e1 tk e2             -> builtin (V.Order V.Gt) (tkProv tk) [e1, e2]

    B.Mul e1 tk e2            -> builtin V.Mul (tkProv tk) [e1, e2]
    B.Div e1 tk e2            -> builtin V.Div (tkProv tk) [e1, e2]
    B.Add e1 tk e2            -> builtin V.Add (tkProv tk) [e1, e2]
    B.Sub e1 tk e2            -> builtin V.Sub (tkProv tk) [e1, e2]
    B.Neg tk e                -> builtin V.Neg (tkProv tk) [e]

    B.Cons e1 tk e2           -> builtin V.Cons (tkProv tk) [e1, e2]
    B.At e1 tk e2             -> builtin V.At   (tkProv tk) [e1, e2]
    B.Map tk e1 e2            -> builtin V.Map  (tkProv tk) [e1, e2]
    B.Fold tk e1 e2 e3        -> builtin V.Fold (tkProv tk) [e1, e2, e3]


instance Elab B.Arg V.InputArg where
  elab (B.ExplicitArg e) = V.Arg Explicit <$> elab e
  elab (B.ImplicitArg e) = V.Arg Implicit <$> elab e
  elab (B.InstanceArg _) = developerError "User specified type classes not yet supported"

instance Elab B.Name V.Identifier where
  elab n = return $ V.Identifier $ tkSymbol n

instance Elab B.Binder V.InputBinder where
  elab = let name = V.User . tkSymbol in \case
    B.ExplicitBinder    n         -> return $ V.Binder (tkProv n) Explicit (name n) (V.Hole (tkProv n) "_")
    B.ImplicitBinder    n         -> return $ V.Binder (tkProv n) Implicit (name n) (V.Hole (tkProv n) "_")
    B.ExplicitBinderAnn n _tk typ -> V.Binder (tkProv n) Explicit (name n) <$> elab typ
    B.ImplicitBinderAnn n _tk typ -> V.Binder (tkProv n) Implicit (name n) <$> elab typ

instance Elab B.LetDecl (V.InputBinder, V.InputExpr) where
  elab (B.LDecl b e) = bitraverse elab elab (b,e)

instance Elab B.Lit V.InputExpr where
  elab = \case
    B.LitTrue  p -> return $ V.LitBool (tkProv p) True
    B.LitFalse p -> return $ V.LitBool (tkProv p) False
    B.LitReal  x -> return $ V.LitReal mempty x
    B.LitInt   n -> return $ if n >= 0
      then V.LitNat mempty (fromIntegral n)
      else V.LitInt mempty (fromIntegral n)

instance Elab B.TypeClass V.InputExpr where
  elab = \case
    B.TCEq    tk e1 e2 -> builtin V.HasEq          (tkProv tk) [e1, e2]
    B.TCOrd   tk e1 e2 -> builtin V.HasOrd         (tkProv tk) [e1, e2]
    B.TCCont  tk e1 e2 -> builtin V.IsContainer    (tkProv tk) [e1, e2]
    B.TCTruth tk e     -> builtin V.IsTruth        (tkProv tk) [e]
    B.TCQuant tk e     -> builtin V.IsQuantifiable (tkProv tk) [e]
    B.TCNat   tk e     -> builtin V.IsNatural      (tkProv tk) [e]
    B.TCInt   tk e     -> builtin V.IsIntegral     (tkProv tk) [e]
    B.TCRat   tk e     -> builtin V.IsRational     (tkProv tk) [e]
    B.TCReal  tk e     -> builtin V.IsReal         (tkProv tk) [e]

op1 :: (MonadElab m, HasProvenance a)
    => (Provenance -> a -> b)
    -> Provenance -> m a -> m b
op1 mk p t = do
  ct <- t
  return $ mk (p <> prov ct) ct

op2 :: (MonadElab m, HasProvenance a, HasProvenance b)
    => (Provenance -> a -> b -> c)
    -> Provenance -> m a -> m b -> m c
op2 mk p t1 t2 = do
  ct1 <- t1
  ct2 <- t2
  return $ mk (p <> prov ct1 <> prov ct2) ct1 ct2

builtin :: MonadElab m => V.Builtin -> Provenance -> [B.Expr] -> m V.InputExpr
builtin b ann args = builtin' b ann <$> traverse elab args

builtin' :: V.Builtin -> Provenance -> [V.InputExpr] -> V.InputExpr
builtin' b p args = V.normAppList p' (V.Builtin p b) (fmap (V.Arg Explicit) args)
  where p' = fillInProvenance (p : map prov args)

elabFunInputType :: MonadElab m => B.Expr -> m V.InputBinder
elabFunInputType t = do
  t' <- elab t
  return $ V.Binder (prov t') Explicit V.Machine t'

elabApp :: MonadElab m => B.Expr -> B.Arg -> m V.InputExpr
elabApp fun arg = do
  fun' <- elab fun
  arg' <- elab arg
  let p = fillInProvenance [prov fun', prov arg']
  return $ V.normAppList p fun' [arg']

elabBindersAndBody :: MonadElab m => [B.Binder] -> B.Expr -> m ([V.InputBinder], V.InputExpr)
elabBindersAndBody bs body = bitraverse (traverse elab) elab (bs, body)

elabQuantifier :: (MonadElab m, IsToken token) => token -> V.Quantifier -> [B.Binder] -> B.Expr -> m V.InputExpr
elabQuantifier t q bs body = do
  checkNonEmpty t bs
  unfoldQuantifier (tkProvenance t) q <$> elabBindersAndBody bs body

elabQuantifierIn :: (MonadElab m, IsToken token) => token -> V.Quantifier -> [B.Binder] -> B.Expr -> B.Expr -> m V.InputExpr
elabQuantifierIn t q bs container body = do
  checkNonEmpty t bs
  unfoldQuantifierIn (tkProvenance t) q <$> elab container <*> elabBindersAndBody bs body

-- |Takes a list of declarations, and groups type and expression
--  declarations by their name.
groupDecls :: MonadElab m => [B.Decl] -> m [V.InputDecl]
groupDecls []       = return []
groupDecls (d : ds) = NonEmpty.toList <$> traverse elab (NonEmpty.groupBy1 cond (d :| ds))
  where
    cond :: B.Decl -> B.Decl -> Bool
    cond d1 d2 = isDefFun d1 && isDefFun d2 && tkSymbol (declName d1) == tkSymbol (declName d2)

    isDefFun :: B.Decl -> Bool
    isDefFun (B.DefFunType _name _args _exp) = True
    isDefFun (B.DefFunExpr _ann _name _typ)  = True
    isDefFun _                               = False

-- |Get the name for any declaration.
declName :: B.Decl -> B.Name
declName (B.DeclNetw   n _ _) = n
declName (B.DeclData   n _ _) = n
declName (B.DefType    n _ _) = n
declName (B.DefFunType n _ _) = n
declName (B.DefFunExpr n _ _) = n

checkNonEmpty :: (MonadElab m, IsToken token) => token -> [a] -> m ()
checkNonEmpty tk = checkNonEmpty' (tkProv tk) (tkSymbol tk)

checkNonEmpty' :: (MonadElab m) => Provenance -> Symbol -> [a] -> m ()
checkNonEmpty' p s []      = throwError $ MissingVariables p s
checkNonEmpty' _ _ (_ : _) = return ()